<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:err="http://www.w3.org/2005/xqt-errors" xmlns:map="http://www.w3.org/2005/xpath-functions/map"
    xmlns:ixsl="http://saxonica.com/ns/interactiveXSLT" xmlns:saxon="http://saxon.sf.net/"
    xmlns:js="http://saxonica.com/ns/globalJS" xmlns:doc="http://www.saxonica.com/ns/documentation"
    xmlns:ixml="http://invisiblexml.org/NS" exclude-result-prefixes="xs js  doc  map saxon  ixsl jwL"
    xmlns:jwL="https://github.com/johnlumley" version="3.0" expand-text="yes">

    <!-- This global variable evaluates to the 'grammar factory' used to parse/compile iXML grammars
        to produce an iXML parser for the selected grammar.
        The jwiXML() function has been attached to the browser window object at the end of the evalution of the 
        jwiXML JavaScript library script
    -->
    <xsl:variable name="jwiXML" select="js:jwiXML()"/>
    
    <!-- Version identifier -->
    <xsl:function name="jwL:version" as="xs:string">
        <xsl:sequence select="ixsl:call($jwiXML, 'version', [])"/>
    </xsl:function>

    <!-- 
    These are the calls to compile or just parse an iXML grammar
    They use the 'grammar factory' generated by the evaluation of jwiXML() 
    bound to the global variable jwiXML above
    
        jwL:compileGrammar() produces a fully compiled grammar suitable for parsing input text strings
        jwl:parseGrammar() generates an internal parse object of the iXML grammar supplied, from which
              an XML-exported form can be retrieved via its display() method, viz:
                    ixsl:call($parsedGrammar,'display',[])  (THE NAME MAY CHANGE!)
    -->
    <xsl:function name="jwL:compileGrammar" as="item()">
        <xsl:param name="grammarSource" as="item()"/>
        <xsl:sequence select="jwL:compileGrammar($grammarSource, map {})"/>
    </xsl:function>
    <xsl:function name="jwL:compileGrammar" as="item()">
        <xsl:param name="grammarSource" as="item()"/>
        <xsl:param name="options" as="map(*)"/>
        <xsl:sequence select="ixsl:call($jwiXML, 'compile', [$grammarSource, $options])"/>
    </xsl:function>
    <xsl:function name="jwL:parseGrammar" as="item()">
        <xsl:param name="grammarSource" as="item()"/>
        <xsl:sequence select="ixsl:call($jwiXML, 'parse', [$grammarSource])"/>
    </xsl:function>

    <!-- 
    These are the calls to parse an input string against a compiled grammar
    $options is a map of control options, currently supporting:
    
        justOne - xs:boolean - if true in the case of ambiguity only a single parse tree is generated,
                       though it is marked as @ixml:state="ambiguous"
        suppressMarks - xs:boolean - if true marks for ignore (-), attribute (@) or insertion (+) serialisation 
                       are not honoured but rather placed on the full parse tree output either as an @ixml:mark attribute
                       or an ixml:insert element. This ony applies to marks on the original grammar and not to
                       artefactual marks, such as used for generated non-terminals for optionality or repetition.
        twRewrites - xs:boolean - use the Tovey-Walsh rewrite rule for f+ constructs, rather than that given in the spec.
                        (This will likely be the default in future - seems to be O(5x) faster)
        
    The result is a map with the following main entries:
        
        parsed - xs:boolean - whether the input could be parsed as a sentence in the grammar
        tree - document-node() - the principal parse tree of the result, or an error report in the case of parsing failure
        allTrees - document-node()+ - the ambiguous alternative trees in case of ambiguity
                        allTrees[1] and tree should be the same document
     
     In addition an entry 'failed' will exist in the case of a failure to parse containing relevant information
     and an entry 'error-code' in the case where an error-code is available. This information will also be
     repeated in the 'tree' document as text and/or an attribute.
     
     There are other fields relevant to debugging and timing performance.
     
    -->
    <xsl:function name="jwL:parse" as="map(*)">
        <xsl:param name="grammar"/>
        <xsl:param name="input" as="xs:string"/>
        <xsl:sequence select="jwL:parse($grammar, $input, map {'justOne': false()})"/>
    </xsl:function>
    <xsl:function name="jwL:parse" as="map(*)">
        <xsl:param name="grammar"/>
        <xsl:param name="input" as="xs:string"/>
        <xsl:param name="options" as="map(*)"/>
        <xsl:sequence select="ixsl:call($grammar, 'parse', [$input, $options])"/>
    </xsl:function>
    
    <!-- 
    These are the calls to parse an input string consiting of a sequence of records,
    each record being parsed separately against a compiled grammar.
    $seperator - xs:string - a regular expression to define the record-separating string
    $options is a map of control options, as defined above, though at present justOne is effectively treated as true no matter what the setting,
    -->
    <xsl:function name="jwL:parseRecords" as="element()*">
        <xsl:param name="grammar"/>
        <xsl:param name="input" as="xs:string"/>
        <xsl:sequence select="jwL:parseRecords($grammar, $input, '\n')"/>
    </xsl:function>
    <xsl:function name="jwL:parseRecords" as="element()*">
        <xsl:param name="grammar"/>
        <xsl:param name="input" as="xs:string"/>
        <xsl:param name="separator" as="xs:string"/>
        <xsl:sequence select="jwL:parseRecords($grammar, $input, $separator, map {'justOne': true()})"/>
    </xsl:function>
    <xsl:function name="jwL:parseRecords" as="element()*">
        <xsl:param name="grammar"/>
        <xsl:param name="input" as="xs:string"/>
        <xsl:param name="separator" as="xs:string"/>
        <xsl:param name="options" as="map(*)"/>
        <xsl:for-each select="tokenize($input, $separator)">
            <xsl:sequence select="ixsl:call($grammar, 'parse', [., $options])?tree/*"/>
        </xsl:for-each>
    </xsl:function>

</xsl:stylesheet>
